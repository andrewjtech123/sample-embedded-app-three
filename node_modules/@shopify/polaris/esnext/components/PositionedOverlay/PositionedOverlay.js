import * as tslib_1 from "tslib";
import * as React from 'react';
import { autobind } from '@shopify/javascript-utilities/decorators';
import { classNames } from '@shopify/react-utilities/styles';
import { getRectForNode, Rect } from '@shopify/javascript-utilities/geometry';
import { closest } from '@shopify/javascript-utilities/dom';
import EventListener from '../EventListener';
import Scrollable from '../Scrollable';
import { layer } from '../shared';
import { calculateVerticalPosition, calculateHorizontalPosition, rectIsOutsideOfRect, } from './utilities/math';
import * as styles from './PositionedOverlay.scss';
export default class PositionedOverlay extends React.PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            measuring: true,
            activatorRect: getRectForNode(this.props.activator),
            left: 0,
            top: 0,
            height: 0,
            width: null,
            positioning: 'below',
            zIndex: null,
            outsideScrollableContainer: false,
            lockPosition: false,
        };
        this.overlay = null;
        this.scrollableContainer = null;
    }
    componentDidMount() {
        this.scrollableContainer = Scrollable.forNode(this.props.activator);
        if (this.scrollableContainer && !this.props.fixed) {
            this.scrollableContainer.addEventListener('scroll', this.handleMeasurement);
        }
        this.handleMeasurement();
    }
    componentWillUnmount() {
        if (this.scrollableContainer && !this.props.fixed) {
            this.scrollableContainer.removeEventListener('scroll', this.handleMeasurement);
        }
    }
    // eslint-disable-next-line react/no-deprecated
    componentWillReceiveProps() {
        this.handleMeasurement();
    }
    componentDidUpdate() {
        const { outsideScrollableContainer, top } = this.state;
        const { onScrollOut, active } = this.props;
        if (active &&
            onScrollOut != null &&
            top !== 0 &&
            outsideScrollableContainer) {
            onScrollOut();
        }
    }
    render() {
        const { left, top, zIndex, width } = this.state;
        const { render, fixed } = this.props;
        const style = {
            top: top == null ? undefined : top,
            left: left == null ? undefined : left,
            width: width == null ? undefined : width,
            zIndex: zIndex == null ? undefined : zIndex,
        };
        const className = classNames(styles.PositionedOverlay, fixed && styles.fixed);
        return (<div className={className} style={style} ref={this.setOverlay}>
        <EventListener event="resize" handler={this.handleMeasurement}/>
        {render(this.overlayDetails())}
      </div>);
    }
    overlayDetails() {
        const { measuring, left, positioning, height, activatorRect } = this.state;
        return {
            measuring,
            left,
            desiredHeight: height,
            positioning,
            activatorRect,
        };
    }
    setOverlay(node) {
        this.overlay = node;
    }
    handleMeasurement() {
        const { lockPosition, top } = this.state;
        this.setState({
            left: 0,
            top: lockPosition ? top : 0,
            height: 0,
            positioning: 'below',
            measuring: true,
        }, () => {
            if (this.overlay == null || this.scrollableContainer == null) {
                return;
            }
            const { activator, preferredPosition = 'below', preferredAlignment = 'center', onScrollOut, fullWidth, fixed, } = this.props;
            const textFieldActivator = activator.querySelector('input');
            const activatorRect = textFieldActivator != null
                ? getRectForNode(textFieldActivator)
                : getRectForNode(activator);
            const currentOverlayRect = getRectForNode(this.overlay);
            const scrollableElement = isDocument(this.scrollableContainer)
                ? document.body
                : this.scrollableContainer;
            const scrollableContainerRect = getRectForNode(scrollableElement);
            const overlayRect = fullWidth
                ? Object.assign({}, currentOverlayRect, { width: activatorRect.width }) : currentOverlayRect;
            // If `body` is 100% height, it still acts as though it were not constrained
            // to that size. This adjusts for that.
            if (scrollableElement === document.body) {
                scrollableContainerRect.height = document.body.scrollHeight;
            }
            const overlayMargins = this.overlay.firstElementChild
                ? getMarginsForNode(this.overlay.firstElementChild)
                : { activator: 0, container: 0, horizontal: 0 };
            const containerRect = windowRect();
            const zIndexForLayer = getZIndexForLayerFromNode(activator);
            const zIndex = zIndexForLayer == null ? zIndexForLayer : zIndexForLayer + 1;
            const verticalPosition = calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed);
            const horizontalPosition = calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment);
            this.setState({
                measuring: false,
                activatorRect: getRectForNode(activator),
                left: horizontalPosition,
                top: lockPosition ? top : verticalPosition.top,
                lockPosition: Boolean(fixed),
                height: verticalPosition.height || 0,
                width: fullWidth ? overlayRect.width : null,
                positioning: verticalPosition.positioning,
                outsideScrollableContainer: onScrollOut != null &&
                    rectIsOutsideOfRect(activatorRect, intersectionWithViewport(scrollableContainerRect)),
                zIndex,
            });
        });
    }
}
tslib_1.__decorate([
    autobind
], PositionedOverlay.prototype, "overlayDetails", null);
tslib_1.__decorate([
    autobind
], PositionedOverlay.prototype, "setOverlay", null);
tslib_1.__decorate([
    autobind
], PositionedOverlay.prototype, "handleMeasurement", null);
function intersectionWithViewport(rect) {
    const viewport = windowRect();
    return new Rect({
        top: Math.max(rect.top, 0),
        left: Math.max(rect.left, 0),
        height: Math.min(rect.height - rect.top + viewport.top, viewport.height, viewport.height - rect.top),
        width: Math.min(rect.width - rect.left + viewport.left, viewport.width, viewport.width - rect.left),
    });
}
function getMarginsForNode(node) {
    const nodeStyles = window.getComputedStyle(node);
    return {
        activator: parseFloat(nodeStyles.marginTop || ''),
        container: parseFloat(nodeStyles.marginBottom || ''),
        horizontal: parseFloat(nodeStyles.marginLeft || ''),
    };
}
function getZIndexForLayerFromNode(node) {
    const layerNode = closest(node, layer.selector) || document.body;
    const zIndex = layerNode === document.body
        ? 'auto'
        : parseInt(window.getComputedStyle(layerNode).zIndex || '0', 10);
    return zIndex === 'auto' || isNaN(zIndex) ? null : zIndex;
}
function windowRect() {
    return new Rect({
        top: window.scrollY,
        left: window.scrollX,
        height: window.innerHeight,
        width: window.innerWidth,
    });
}
function isDocument(node) {
    return node === document;
}
